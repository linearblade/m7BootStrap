/**
 * DomRegistry
 *
 * A lightweight DOM tracking utility for managing dynamically inserted elements.
 * Primarily used for scene/module cleanup and DOM lifecycle control in dynamic applications.
 *
 * Features:
 * - Tracks DOM elements with auto-assigned or symbolic IDs
 * - Supports logical grouping (e.g., "scene:menu", "hud") for batch operations
 * - Can optionally remove elements from the DOM when released
 * - Uses a Map internally for consistent key-based tracking
 *
 * Methods:
 * - track(el, opts): Track an element (with optional id/group/user metadata)
 * - release(el, destroy): Stop tracking (and optionally remove from DOM)
 * - clear(group, destroy): Remove all or grouped elements from registry (and optionally DOM)
 * - list(group): Return tracked IDs (optionally filtered by group)
 * - listGroups(): Return all group names in use
 * - resolveDom(ref): Resolve an element via direct DOM, ID string, or `$trackerRef`
 *
 * Internal:
 * - _makeID(id): Allocates or validates a unique ID
 * - _lookup(ref): Internal lookup by DOM node or ID
 *
 * Example:
 *   dom.track(someEl, { group: "scene:game" });
 *   dom.clear("scene:game", true);  // removes all and detaches from DOM
 *
 */
class DomRegistry{
    constructor () {
	this.runMAX = 50;
	this.counter = 0;
	this.tracker = new Map();
    }


    /**
     * Tracks a DOM element under a unique ID.
     *
     * @param {HTMLElement} e - The element to track.
     * @param {Object|string|number} [opts={}] - Optional tracking config or shorthand ID.
     *   - `id`: (string|number) Optional explicit tracking ID
     *   - `group`: (string) Optional group name for logical grouping (e.g., "scene:map")
     *   - `user`: (object) Optional user metadata
     * @returns {boolean} True if tracking succeeded; false otherwise.
     */
    track(e, opts = {}) {
	// Bail if no element provided or element is already tracked
	if (!e || this._lookup(e)) return false;

	// Normalize opts: support string/number shorthand for ID
	if (typeof opts === 'string' || typeof opts === 'number') {
	    opts = { id: String(opts) };
	} else if (typeof opts !== 'object' || opts === null) {
	    opts = {};
	}

	// Attempt to allocate a valid tracking ID
	const id = this._makeID(opts.id);
	if (!id) return false;

	// Create and store tracking record
	this.tracker.set(id,  {
	    e,
	    id,
	    group: opts.group || 'none',
	    user: opts.user || {}
	} );

	return true;
    }

    /**
     * Stops tracking a previously registered DOM element.
     *
     * Optionally removes the element from the DOM as well.
     *
     * @param {HTMLElement|string} e - The element or symbolic ID to release.
     * @param {boolean} [destroy=false] - If true, also removes the element from the DOM.
     * @returns {boolean} True if the element was found and untracked; false otherwise.
     */

    release(e, destroy = false) {
	const rec = this._lookup(e);
	if (!rec) return false;

	if (destroy && rec.e?.parentNode) {
	    rec.e.parentNode.removeChild(rec.e);
	}

	this.tracker.delete(rec.id);
	return true;
    }
    
    /**
     * Resolves a target reference into a DOM element.
     *
     * Accepts:
     * - A DOM element
     * - A tracker key string (e.g., "$overlay")
     * - A raw DOM ID (e.g., "map-container")
     * - A fallback value if the input is invalid
     *
     * @param {HTMLElement|string|null} e - The element or reference to resolve
     * @param {HTMLElement|string|null} defTarget - Optional fallback target if `e` fails
     * @returns {HTMLElement|undefined} The resolved DOM element, or undefined
     */
    resolveDom(e, defTarget = undefined) {
	// If it's already a DOM element
	if (e instanceof Element) return e;

	// If it's a scalar string or number
	if (typeof e === 'string' || typeof e === 'number') {
	    const ref = String(e);

	    // Symbolic tracker ref: "$overlay" â†’ lookup("overlay")
	    if (ref.startsWith('$')) {
		const tracked = this._lookup(ref.slice(1));
		if (tracked) return tracked.e;
	    }

	    // Otherwise treat as DOM ID
	    return document.getElementById(ref);
	}

	// Try fallback if provided
	if (defTarget !== undefined) {
	    return this.resolveDom(defTarget);
	}

	return undefined;
    }

    /**
     * Retrieves a tracked entry by DOM element reference or symbolic ID.
     * internal method
     *
     * @param {HTMLElement|string|number} e - The element or ID to look up.
     * @returns {Object|undefined} The tracking record, or undefined if not found.
     */
    _lookup(e) {
	if (e instanceof Element) {
	    // Lookup by DOM reference
	    for (const [, item] of this.tracker.entries()) {
		if (item.e === e) return item;
	    }
	} else if (typeof e === 'string' || typeof e === 'number') {
	    // Lookup by ID
	    return this.tracker.get(String(e));
	}

	return undefined;
    }

    /**
     * Generates a unique ID for tracking DOM elements.
     *
     * Behavior:
     * - If a manual `id` is provided (string or number):
     *     - Returns the string form of the ID if not already tracked.
     *     - Returns `undefined` if the ID is invalid or already in use.
     *
     * - If no ID is provided:
     *     - Attempts to generate a numeric ID (as a string) by incrementing `this.counter`.
     *     - Will try up to `this.runMAX` times before giving up and returning `undefined`.
     *
     * @param {string|number} [id] - Optional manual ID to validate or assign.
     * @returns {string|undefined} - A unique ID string, or `undefined` if generation failed.
     **/
    _makeID(id) {
	// If an ID is explicitly provided
	if (id !== undefined && id !== null) {
	    const type = typeof id;
	    if (type !== 'string' && type !== 'number') return undefined;

	    const strID = String(id);
	    if (this.tracker.has(strID)) return undefined;

	    return strID;
	}

	// Otherwise, generate a unique numeric ID
	let attempts = 0;
	while (attempts++ < this.runMAX) {
	    const autoID = String(this.counter++);
	    if (!this.tracker.has(autoID)) return autoID;
	}

	// Failed to generate a unique ID
	return undefined;
    }
    
    /**
     * Lists all tracked IDs.
     *
     * @param {string|null} group - Optional group name to filter by. If null, returns all IDs.
     * @returns {string[]} Array of matching tracker IDs.
     */
    list(group = null) {
	if (group === null) {
	    return Array.from(this.tracker.keys());
	}

	const result = [];
	for (const [id, rec] of this.tracker.entries()) {
	    if (rec.group === group) result.push(id);
	}
	return result;
    }
    
    /**
     * Clears tracked elements.
     *
     * @param {string|null} group - If specified, only clears elements in this group.
     * @param {boolean} destroy - If true, also removes elements from the DOM.
     */

    clear(group = null, destroy = false) {
	if (group === null) {
	    // Clear everything
	    for (const id of this.tracker.keys()) {
		this.release(id, destroy);
	    }
	    this.counter = 0;
	    return;
	}

	// Clear only matching group
	for (const [id, rec] of this.tracker.entries()) {
	    if (rec.group === group) {
		this.release(id, destroy);
	    }
	}
    }

    /**
     * Returns a list of all group names currently in use.
     *
     * @returns {string[]} Unique group names found in the tracker.
     */

    listGroups() {
	const groups = new Set();

	for (const rec of this.tracker.values()) {
	    groups.add(rec.group || 'none');
	}

	return Array.from(groups);
    }   
}
