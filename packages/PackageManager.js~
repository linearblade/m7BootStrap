export class PackageManager {
    /**
     * Initializes the BootStrap system.
     *
     * @param {BootStrap} bootstrap - A valid BootStrap instance for bootstrapping management, networking and loaders.
     * @param {Object} [options={}] - Optional configuration.
     * @param {Object} [options.repo={}] - Initial repo configuration passed to the Repo manager.
     */
    constructor(bootstrap) {

	if (!bootstrap || typeof bootstrap !== 'object') {
            throw new Error("BootStrap requires a valid bootstrap controller instance");
	}
	this.bootstrap = bootstrap;
	this.net = bootstrap.net;

	this.packages = new Map();   // Cache of loaded packages by local ID
	this.assets = new Map();     // Registry of loaded assets (DOM, CSS, etc.)
	this.modules = new Map();    // Loaded JS module references

	this.repo = this.bootstrap.repo;
    }    
    /**
     * Loads a package by ID or JSON path.
     * @param {string|object} def - Package ID or direct definition
     * @returns {Promise<void>}
     */

    async loadPackage(pkg) {
	//we will handle this later.
	//const pkg = await this.repo.load(def);

	if (!pkg || typeof pkg !== 'object') {
            throw new Error("loadPackage() requires a fully resolved package object.");
	}

	const lid = pkg.lid || pkg.id;
	
	if (this.packages.has(lid)) {
            console.warn(`Package "${lid}" already loaded.`);
            return;
	}

	// Cache the definition
	this.packages.set(lid, pkg);
	const assetSuccess = await this._loadAssets(pkg);
	console.log('got here');
	const modSuccess   = await this._loadModules(pkg);
	const hookSuccess = await this._runHooks(pkg);
	// TODO: load requires → load assets → run hooks

	        // TODO:
        // - resolve remote path if string and ends in .json
        // - resolve local package from registry otherwise
        // - check for already-loaded
        // - load requires
        // - load assets
        // - run hooks

    }


    async _runHooks(pkg) {
	if (!pkg?.run || !Array.isArray(pkg.run)) return;

	for (const entry of pkg.run) {
	    try {
		if (typeof entry === 'function') {
		    await entry(); // Direct function
		} else if (typeof entry === 'string' && entry.startsWith('@')) {
		    const [modID, fnName] = entry.slice(1).split('.');
		    const mod = this.modules.get(modID);
		    const fn = mod?.[fnName];

		    if (typeof fn === 'function') {
			await fn();
		    } else {
			console.warn(`[BootStrap] Missing function '${fnName}' in module '${modID}'`);
		    }
		} else {
		    console.warn(`[BootStrap] Unsupported run hook:`, entry);
		}
	    } catch (err) {
		console.error(`[BootStrap] Error in run hook '${entry}':`, err);
	    }
	}
    }

    async _loadModules(pkg) {
	const base = pkg.__meta?.base || '';
	const mods = pkg.modules || [];

	for (const { id, url } of mods) {
	    const fullURL = base + url;
	    try {
		const mod = await this.net.modules.load(id,fullURL);
		this.modules.set(id, mod);
	    } catch (err) {
		console.warn(`Failed to import module: ${id} → ${fullURL}`, err);
		return false;
	    }
	}
	return true;
    }

    /**
     * Internal: Loads all assets from a package.
     *
     * @param {object} pkg - A full package object containing an `assets` array.
     * @returns {Promise<void>}
     */

    async _loadAssets(pkg) {
	if (!pkg?.assets || !Array.isArray(pkg.assets)) return;

	const base = pkg.__meta?.base || '';

	const loadList = pkg.assets.map(asset => ({
            id: asset.id,
            url: `${base}${asset.url}` // prepend base if present
	}));
	
	// Use net.batch
	const oldHandler = this.net.batch.batchHandler;
	this.net.batch.setBatchHandler(this.net.batch.batchStatus); // use default behavior (batchStatus);
	

	
	const {sync,results:batchResults} = await  this.net.batch.run(
	    loadList,
	    (opts) => {
		console.log(`pulled ${opts.trigger}`,opts);
	    },
	    ({ trigger }) => {
		console.warn(`Failed to load asset: ${trigger}`);
	    },
	    {awaitAll:true}
	);

	console.warn([this.net.batch.context,sync.controller, sync.failed(),batchResults]);
	//window.sync = sync;
	this.net.batch.setBatchHandler(oldHandler); // restore if needed
	for (const {id} of loadList){
	    console.log(`storing ${id}`, this.net.batch.get(id) );
	    this.assets.set(id,this.net.batch.context[id]);
	}
	if (sync.failed() ){
	    // handle a failure
	    return false;
	}
	return true;
	//for (const k in sync.controller.fail)console.warn(k);

    }
    

    /**
     * Evaluates all run instructions in order.
     * @param {Array<Function|string|object>} runList
     */
    async runHooks(runList) {
        // TODO:
        // - resolve string refs like "@id.fn"
        // - resolve { call, args }
        // - fallback to global function names
    }

    /**
     * Optional helper to unload assets by group or package ID.
     * @param {string} id
     */
    unloadPackage(id) {
        // TODO: use domRegistry.clear(id), remove cached entries
    }
}
export default PackageManager;
